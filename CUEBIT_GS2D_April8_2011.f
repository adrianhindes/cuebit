	module declare
	implicit none
	double precision :: e,rm,twopi,za,aa,r1,phi1,vr1,vphi1
	double precision :: vz0,dt,fi,vsq,t,err,errphi,b1,det,phi2
	double precision :: x,y,z,x1,y1,z1,vx1,vy1,vz1,vx2,vy2,vz2
	double precision :: bx,by,ax,ay,az,r,r2,phi,errpphi,phid
	double precision :: x2,y2,z2,phideg,psi1,pphi0,vr2
	double precision :: vphi2,vsq2,psi2,pphi2
	double precision :: rg1,rg2,zg1,zg2,deltar,deltaz
	double precision :: psirg1,psirg2,psizg1,psizg2
	integer :: i,j,nt,i1,i2
	character(len=20) :: tch,rch,phich,zch,deech,depphich
	end module declare 

      program full_orbit_MAST_Aug22
      use declare
      implicit none
      real :: terp2
      external coeff1,terp1,coeff2,terp2
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccc                                                                      ccc
ccc This program reads in a MAST equilibrium reconstruction generated by ccc
ccc the code GS2D. It then computes the full orbit of a particle in that ccc  
ccc equilibrium.                                                         ccc
ccc                                                                      ccc
ccc Last modified 22/8/02.                                               ccc
ccc                                                                      ccc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
      double precision,dimension(:),allocatable::ps,amin,q,f,p,pp
      double precision,dimension(:),allocatable::rsep,zsep,rgrid,zgrid
      double precision,dimension(:,:),allocatable::psi,bphi
      double precision,dimension(:,:),allocatable:: br,bz
      double precision,dimension(:,:),allocatable:: pxx,pyy,pxxyy
      double precision,dimension(:,:),allocatable:: bxx,byy,bxxyy
      double precision :: r0,a,rmag,zmag,pi,dz,dr
      double precision :: psmin,psip,b0,ippsi
      double precision :: brr,bph,bzz
      integer :: nsu,nsep,nr,nz,nm
      character(len=80) :: line
      integer :: iop(2),isrch,int1
      integer :: itab(3),lenw,lenf,lenwk
      integer :: ibd(4),ixd,iyd,isav,jsav,idm
      double precision :: w(100),tab(3),wk(301)
      open(1,file="gs2.dat",status='unknown')
      do i=1,6
         read(1,fmt='(a80)') line
      enddo
      read(1,*) r0,a,rmag,zmag
      read(1,fmt='(a80)') line ; read(1,*) psmin,psip,b0,ippsi
      read(1,fmt='(a80)') line ; read(1,*) nsu
      allocate(ps(nsu),amin(nsu),q(nsu),f(nsu),p(nsu),pp(nsu))
      read(1,fmt='(a80)') line ; read(1,fmt='(1p,8e12.4)') ps
      read(1,fmt='(a80)') line ; read(1,fmt='(1p,8e12.4)') amin
      read(1,fmt='(a80)') line ; read(1,fmt='(1p,8e12.4)') q
      read(1,fmt='(a80)') line ; read(1,fmt='(1p,8e12.4)') f
      read(1,fmt='(a80)') line ; read(1,fmt='(1p,8e12.4)') p
      read(1,fmt='(a80)') line ; read(1,fmt='(1p,8e12.4)') pp
      read(1,fmt='(T22,I6)') nsep
      allocate(rsep(nsep),zsep(nsep))
      read(1,fmt='(a80)') line ; read(1,fmt='(1p,8e12.4)') rsep
      read(1,fmt='(a80)') line ; read(1,fmt='(1p,8e12.4)') zsep
      read(1,fmt='(a80)') line ; read(1,*) nr,nz
      allocate(rgrid(nr),zgrid(nz),psi(nr,nz),bphi(nr,nz))
      allocate(br(nr,nz),bz(nr,nz))
      allocate(pxx(nr,nz),pyy(nr,nz),pxxyy(nr,nz))
      allocate(bxx(nr,nz),byy(nr,nz),bxxyy(nr,nz))
      read(1,fmt='(a80)') line ; read(1,*) rgrid
      read(1,fmt='(a80)') line ; read(1,*) zgrid
      read(1,fmt='(a80)') line ; read(1,fmt='(1p,8e12.4)') psi
      close(1)
c
c Evaluate BR 
c
      pi=4.d0*atan(1.d0)
      do i=1,nr
         do j=1,nz
            if (j.eq.1) then 
	      dz=zgrid(j+1)-zgrid(j)   
              br(i,j)=(psi(i,j+1)-psi(i,j))/dz/2.d0/pi/rgrid(i)
	    else if (j.eq.nz) then
	      dz=zgrid(j)-zgrid(j-1)
              br(i,j)=(psi(i,j)-psi(i,j-1))/dz/2.d0/pi/rgrid(i)
            else       
              dz=zgrid(j+1)-zgrid(j-1)
              br(i,j)=(psi(i,j+1)-psi(i,j-1))/dz/2.d0/pi/rgrid(i)
	    end if
         enddo
      enddo
c
c
c Evaluate BZ 
c
      do j=1,nz
         do i=1,nr
            if (i.eq.1) then
              dr=rgrid(i+1)-rgrid(i)
              bz(i,j)=-(psi(i+1,j)-psi(i,j))/dr/2.d0/pi/rgrid(i)
            else if (i.eq.nr) then
              dr=rgrid(i)-rgrid(i-1)
              bz(i,j)=-(psi(i,j)-psi(i-1,j))/dr/2.d0/pi/rgrid(i)
	    else
              dr=rgrid(i+1)-rgrid(i-1)
              bz(i,j)=-(psi(i+1,j)-psi(i-1,j))/dr/2.d0/pi/rgrid(i)
	    end if
         enddo
      enddo
c
c
c Evaluate Bphi 
c
      do i=1,nr
         do j=1,nz
         iop(1)=2
         iop(2)=2
         w(1)=0.d0
         w(nsu)=0.d0
         itab(1)=1
         itab(2)=1
         itab(3)=1
         isrch=1
         int1=1
         call coeff1(nsu,ps,lenf,f,lenw,w,iop,int1,wk)
         call terp1(nsu,ps,lenf,f,lenw,w,psi(i,j),int1,tab,itab,isrch)
         bphi(i,j)=tab(1)/rgrid(i)
         enddo
      enddo
c
      open(1,file="gs2_copy.dat",status='unknown')
      write(1,fmt='("GS2 input file")')
      write(1,fmt='("r0,a,rmag,zmag")')
      write(1,fmt='(1p,4e12.4)')r0,a,rmag,zmag
      write(1,fmt='("psmin,psip,b0,ippsi")')
      write(1,fmt='(1p,4e12.4)')psmin,psip,b0,ippsi
      write(1,fmt='("nfs"/I6)') nsu
      write(1,fmt='("Psi on 1d grid (for FS quantities) (T)")')
      write(1,fmt='(1p,8e12.4)') ps
      write(1,fmt='("amin (m)")')
      write(1,fmt='(1p,8e12.4)') amin
      write(1,fmt='("q")')
      write(1,fmt='(1p,8e12.4)') q
      write(1,fmt='("f =r B_phi (Tm)")')
      write(1,fmt='(1p,8e12.4)') f
      write(1,fmt='("p (Pa)")')
      write(1,fmt='(1p,8e12.4)') p
      write(1,fmt='("dp/dpsi (Pa/Wb)")')
      write(1,fmt='(1p,8e12.4)') pp
      write(1,fmt='("No of points on LCFS=",I6)') nsep
      write(1,fmt='("r(j) (m) on LCFS")')
      write(1,fmt='(1p,8e12.4)') rsep
      write(1,fmt='("z(j) (m) on LCFS")')
      write(1,fmt='(1p,8e12.4)') zsep
      write(1,fmt='("NR",T14,"NZ"/2I6)') NR, NZ
      write(1,fmt='("rgrid (m)")')
      write(1,fmt='(1p,8e12.4)') rgrid
      write(1,fmt='("zgrid (m)")')
      write(1,fmt='(1p,8e12.4)') zgrid
      write(1,fmt='("Psi on grid (Wb) : NB Br=(1/2pi r)*dpsi/dz")')
      write(1,fmt='(1p,8e12.4)') psi
      close(1)
c
c This part of the program computes the orbit
c
c
c Initiate output file
c
      open(8,file="gs2_orbit.dat",status='unknown')
      open(9,file="gs2_RZ_orbit.dat",status='unknown')
	tch="    t(s)"
	rch="    R(m)"
	phich="   phi(deg)"
	zch="     Z(m)  "
c	deech="  E change "
	deech="    psi    "
	depphich="Pphi change"
	write(8,fmt='(6a11)')tch,rch,phich,zch,deech,depphich
c
c Electron charge, proton mass and pi
c
	e=1.602d-19
	rm=1.672d-27
	pi=4.d0*atan(1.d0)
	twopi=2.d0*pi
c
c Input particle atomic & mass numbers, Z & A
c
	write(6,fmt='("Particle atomic & mass numbers, Z & A")')
	read(5,*)za,aa
c
c Input initial conditions
c
	write(6,fmt='("Initial R, phi, Z, vR, vphi, vZ (SI units)")')
	read(5,*)r1,phi1,z1,vr1,vphi1,vz1
c
c Input time step (in units of Larmor period at magnetic axis) & number of 
c time steps
c
	write(6,fmt='("delta-t, no. of steps & frac. of steps output")')
	read(5,*)dt,nt,fi
	dt=2.d0*pi*aa*rm/za/e/abs(b0)*dt
	vsq=vr1**2+vphi1**2+vz1**2
c
	t=0.d0
	x1=r1*cos(phi1)
	y1=r1*sin(phi1)
	vx1=vr1*cos(phi1)-vphi1*sin(phi1)
	vy1=vr1*sin(phi1)+vphi1*cos(phi1)
	err=0.d0
	errpphi=0.d0
	vz0=vz1
	phideg=phi1*180.d0/pi
c
c Evaluate initial magnetic field using interpolation
c
	deltar=1.d-6
	deltaz=1.d-6
        idm=nr
	lenwk=301
	ibd(1)=4
	ibd(2)=4
	ibd(3)=4
	ibd(4)=4
        ixd=0
        iyd=0
	isrch=1
        call coeff2(nr,rgrid,nz,zgrid,psi,pxx,pyy,pxxyy,idm,ibd,
     1      lenwk,wk)
        idm=nr
	lenwk=196
	ibd(1)=4
	ibd(2)=4
	ibd(3)=4
	ibd(4)=4
        call coeff2(nr,rgrid,nz,zgrid,bphi,bxx,byy,bxxyy,idm,ibd,
     1      lenwk,wk)
c
	rg1=r1-deltar
	rg2=r1+deltar
	zg1=z1-deltaz
	zg2=z1+deltaz
c 
	psirg1=terp2(rg1,z1,nr,rgrid,nz,zgrid,psi,pxx,pyy,pxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
	psirg2=terp2(rg2,z1,nr,rgrid,nz,zgrid,psi,pxx,pyy,pxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
	psizg1=terp2(r1,zg1,nr,rgrid,nz,zgrid,psi,pxx,pyy,pxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
	psizg2=terp2(r1,zg2,nr,rgrid,nz,zgrid,psi,pxx,pyy,pxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
	brr=(psizg2-psizg1)/2.d0/deltaz/r1/2.d0/pi
	bzz=-(psirg2-psirg1)/2.d0/deltar/r1/2.d0/pi
	bph=terp2(r1,z1,nr,rgrid,nz,zgrid,bphi,bxx,byy,bxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
c	bph=0.4/r1
c
	bx=brr*cos(phi1)-bph*sin(phi1)
	by=brr*sin(phi1)+bph*cos(phi1)
	psi1=terp2(r1,z1,nr,rgrid,nz,zgrid,psi,pxx,pyy,pxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
	pphi0=aa*rm*r1*vphi1-za*e*psi1/twopi
	write(8,fmt='(1p,6d11.3)')t,r1,phideg,z1,psi1,errpphi
	write(9,fmt='(1p,2d11.3)')r1,z1
c
c Commence time loop
c
	do i=2,nt
	t=t+dt
c
c Commence iteration loop
c
	x2=x1
	y2=y1
	z2=z1
	do j=1,3
	x=(x1+x2)/2.d0
	y=(y1+y2)/2.d0
	z=(z1+z2)/2.d0
	r=sqrt(x**2+y**2)
	phi=atan(y/x)
	if(x.lt.0.d0)phi=phi+pi
	if(x.gt.0.d0.and.y.lt.0.d0)phi=phi+twopi
	if(phi.gt.twopi)phi=phi-twopi
c
c Evaluate magnetic field components
c
	rg1=r-deltar
	rg2=r+deltar
	zg1=z-deltaz
	zg2=z+deltaz
c 
	psirg1=terp2(rg1,z,nr,rgrid,nz,zgrid,psi,pxx,pyy,pxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
	psirg2=terp2(rg2,z,nr,rgrid,nz,zgrid,psi,pxx,pyy,pxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
	psizg1=terp2(r,zg1,nr,rgrid,nz,zgrid,psi,pxx,pyy,pxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
	psizg2=terp2(r,zg2,nr,rgrid,nz,zgrid,psi,pxx,pyy,pxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
	brr=(psizg2-psizg1)/2.d0/deltaz/r/2.d0/pi
	bzz=-(psirg2-psirg1)/2.d0/deltar/r/2.d0/pi
	bph=terp2(r,z,nr,rgrid,nz,zgrid,bphi,bxx,byy,bxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
c	bph=0.4/r
c
	bx=brr*cos(phi)-bph*sin(phi)
	by=brr*sin(phi)+bph*cos(phi)
c
c Evaluate quantities appearing in matrix relating vi and vi+1
c
	ax=za*e*bx/2.d0/aa/rm*dt
	ay=za*e*by/2.d0/aa/rm*dt
	az=za*e*bzz/2.d0/aa/rm*dt
	det=1.d0+ax**2+ay**2+az**2
c
c Advance equation dvx/dt = Ze/m(vy*Bz-vZ*By) 	
c
	vx2=(1.d0+ax**2-ay**2-az**2)*vx1
	vx2=vx2+2.d0*(ay*ax+az)*vy1
	vx2=vx2+2.d0*(az*ax-ay)*vz1
	vx2=vx2/det
c
c Advance equation dvy/dt = Ze/m(vz*Bx-vx*By) 	
c
	vy2=2.d0*(ay*ax-az)*vx1
	vy2=vy2+(1.d0-ax**2+ay**2-az**2)*vy1
	vy2=vy2+2.d0*(ay*az+ax)*vz1
	vy2=vy2/det
c
c Advance equation dvz/dt = Ze/m(vx*By-vy*Bx) 	
c
	vz2=2.d0*(az*ax+ay)*vx1
	vz2=vz2+2.d0*(ay*az-ax)*vy1
	vz2=vz2+(1.d0-ax**2-ay**2+az**2)*vz1
	vz2=vz2/det
c
c Advance equation dx/dt = vx 	
c
	x2=x1+(vx2+vx1)/2.d0*dt
c
c Advance equation dy/dt = vy 	
c
	y2=y1+(vy2+vy1)/2.d0*dt
c
c Advance equation dz/dt = vz 	
c
	z2=z1+(vz2+vz1)/2.d0*dt
c
	r2=sqrt(x2**2+y2**2)
 	enddo
c
	phi2=atan(y2/x2)
	if(x2.lt.0.d0)phi2=phi2+pi
	if(x2.gt.0.d0.and.y2.lt.0.d0)phi2=phi2+twopi
	if(phi2.gt.twopi)phi2=phi2-twopi
	vr2=vx2*cos(phi2)+vy2*sin(phi2)
	vphi2=-vx2*sin(phi2)+vy2*cos(phi2)
	vsq2=vx2**2+vy2**2+vz2**2
	err=abs((vsq2-vsq)/vsq)
	psi2=terp2(r2,z2,nr,rgrid,nz,zgrid,psi,pxx,pyy,pxxyy,idm,
     1      ixd,iyd,isrch,isav,jsav)
	pphi2=aa*rm*r2*vphi2-za*e*psi2/twopi
	errpphi=(pphi2-pphi0)/pphi0
	phid=phi2*180.d0/pi
        i1=idint(1.d0/fi+0.5d0)
        i2=(i/i1)*i1
        if(i2.eq.i)then
	   write(8,fmt='(1p,6d11.3)')t,r2,phid,z2,psi2,errpphi
	   write(9,fmt='(1p,2d11.3)')r2,z2
	end if 
	x1=x2
	y1=y2
	z1=z2
	r1=r2
	phi1=phi2
	vx1=vx2
	vy1=vy2
	vz1=vz2
	vr1=vr2
c	write(6,fmt='(1p,3d11.3)')brr,bzz,bph
 	enddo
	t=9.d0
	r2=9.d0
	phi2=900.d0
	z2=9.d0
	psi2=9.d0
	errpphi=9.d0
	write(8,fmt='(1p,6d11.3)')t,r2,phi2,z2,psi2,errpphi
      end program full_orbit_MAST_Aug22































